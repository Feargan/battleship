/*#include "matrix.h"

template<typename T>
CMatrix<T>::CMatrix()
	: m_BaseWidth(0), m_BaseHeight(0), m_Array(nullptr), m_Rotation(NONE)
{
	rotate(CRotationDir::KEEP);
}

template<typename T>
CMatrix<T>::CMatrix(unsigned int Width, unsigned int Height)
	: m_BaseWidth(Width), m_BaseHeight(Height), m_Rotation(NONE)
{
	m_Array = new T*[m_BaseWidth];
	for (unsigned int i = 0; i < m_BaseWidth; i++)
		m_Array[i] = new T[m_BaseHeight];
	rotate(CRotationDir::KEEP);
}

template<typename T>
CMatrix<T>::~CMatrix()
{
	for (unsigned int i = 0; i < m_BaseWidth; i++)
		delete[] m_Array[i];
	delete[] m_Array;
}

template<typename T>
void CMatrix<T>::insert(unsigned int x, unsigned int y, const CMatrix & other)
{
}

template<typename T>
void CMatrix<T>::move(unsigned int x, unsigned int y, CMatrix& other)
{

}

template<typename T>
void CMatrix<T>::rotate(int Dir)
{
	m_Rotation += (int)Dir;
	if (m_Rotation <= LOWER_BOUND)
		m_Rotation = UPPER_BOUND - 1;
	if (m_Rotation >= UPPER_BOUND)
		m_Rotation = LOWER_BOUND + 1;

	if (m_Rotation == QUARTER || m_Rotation == THREE_QUARTER)
	{
		m_Width = m_BaseHeight;
		m_Height = m_BaseWidth;
	}
	else
	{
		m_Width = m_BaseWidth;
		m_Height = m_BaseHeight;
	}
}

template<typename T>
T& CMatrix<T>::at(unsigned int x, unsigned int y)
{
	evaluate(x, y);
	if (x >= m_Width || y >= m_Height)
		throw std::out_of_range("CMatrix::at()");
	return m_Array[x][y];
}

template<typename T>
const T & CMatrix<T>::at(unsigned int x, unsigned int y) const
{
	evaluate(x, y);
	if (x >= m_Width || y >= m_Height)
		throw std::out_of_range("CMatrix::at() const");
	return m_Array[x][y];
}

template<typename T>
template<typename U>
void CMatrix<T>::set(unsigned int x, unsigned int y, U&& v)
{
	static_assert(std::is_same<typename std::remove_reference<U>::type, T>::value, "CMatrix<T>::set<U>(): template typenames do not match");
	evaluate(x, y);
	if (x >= m_Width || y >= m_Height)
		throw std::out_of_range("CMatrix::set()");
	m_Array[x][y] = std::forward<U>(v);
}

template<typename T>
void CMatrix<T>::evaluate(unsigned int& x, unsigned int& y) const
{
	unsigned int rX, rY;

	switch (m_Rotation)
	{
	case QUARTER:
		rX = m_Width - 1 - y;
		rY = x;
		break;
	case HALF:
		rX = m_Width - 1 - x;
		rY = m_Height - 1 - y;
		break;
	case THREE_QUARTER:
		rX = y;
		rY = m_Height - 1 - x;
		break;
	default:
		rX = x;
		rY = y;
	}

	x = rX;
	y = rY;
}*/