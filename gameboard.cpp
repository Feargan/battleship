#include "gameboard.h"

#include <algorithm>
#include <unordered_map>

CGameBoard::CGameBoard(const CGamePreset* Preset)
{
	m_Preset = Preset;
	if (!m_Preset)
		return;
	auto Pos = m_Preset->getBoardSize();
	m_Field = CField(Pos.first, Pos.second);
	m_Field.fill(CTile(CState::EMPTY));
	m_ShipCounters.resize(Preset->numTemplates(), 0);
}

CGameBoard::CGameBoard(int Width, int Height)
{
	m_Field = CField(Width, Height);
	m_Field.fill(CTile(CState::EMPTY));
}

CGameBoard::CGameBoard(const CGameBoard & r)
	: m_Field(r.m_Field), m_ShipCounters(r.m_ShipCounters), m_Preset(r.m_Preset)
{
	std::unordered_map <std::shared_ptr<const CShip>, std::shared_ptr<CShip> > Remap;
	for (auto& s : r.m_Ships)
	{
		m_Ships.emplace_back(new CShip(*s));
		Remap[s] = m_Ships.back();
	}
	for (int i = 0; i < m_Field.getWidth(); i++)
	{
		for (int j = 0; j < m_Field.getHeight(); j++)
		{
			const auto& Owner = m_Field.at(i, j).getOwner();
			if (Owner)
				m_Field.at(i, j).setOwner(Remap[Owner]);
		}
	}
}
CGameBoard& CGameBoard::operator=(const CGameBoard& r)
{
	CGameBoard s(r);
	std::swap(*this, s);
	return *this;
}

CGameBoard::~CGameBoard()
{

}

bool CGameBoard::canPlace(int x, int y, const CShipTemplate& Template) const
{
	if (m_Preset)
	{
		// check if template was generated by m_Preset
		int Id = Template.getId();
		if (m_ShipCounters[Id] >= m_Preset->getShipAmount(Id))
			return false;
	}
	const auto& Layout = Template.getLayout();
	// check collisions
	if (x + Layout.getWidth() > m_Field.getWidth() || y + Layout.getHeight() > m_Field.getHeight() || x < 0 || y < 0)
		return false;
	for (int i = 0; i < Layout.getWidth(); i++)
		for (int j = 0; j < Layout.getHeight(); j++)
			if (Layout.at(i, j) == 1)
			{
				for (int m = -1; m <= 1; m++)
				{
					for (int n = -1; n <= 1; n++)
					{
						if (!m_Field.checkPoint(i + m + x, j + n + y))
							continue;
						if (m_Field.at(i + m + x, j + n + y).getState() != CState::EMPTY)
							return false;
					}
				}
			}
	return true;
}

bool CGameBoard::place(int x, int y, const CShipTemplate& Template)
{
	if (!canPlace(x, y, Template))
		return false;
	const auto& Layout = Template.getLayout();
	m_Ships.emplace_back(new CShip({ { x,y }, Layout.getRotation(), Template.getId() }));//
    auto& Ship = m_Ships.back();
	for (int i = 0; i < Layout.getWidth(); i++)
	{
		for (int j = 0; j < Layout.getHeight(); j++)
		{
			if (Layout.at(i, j))
			{
				m_Field.set(i+x, j+y, CTile(Ship));
			}
		}
	}
	m_ShipCounters[Template.getId()]++;
	// preset can change
	return true;
}

void CGameBoard::remove(int x, int y)
{
	if (!m_Field.checkPoint(x, y))
		return;
	auto Owner = m_Field.at(x, y).getOwner();
	if (!Owner)
		return;
	m_Field.fill(CTile(CState::EMPTY),
		[Owner](const CTile& t) -> bool
		{
			if (t.getOwner() == Owner)
				return true;
			return false;
		}
	);
	m_ShipCounters[Owner->getMeta().m_TemplateId]--;
	m_Ships.erase(std::remove_if(m_Ships.begin(), m_Ships.end(),
		[Owner](const std::shared_ptr<CShip>& s) -> bool
		{
			if (Owner == s)
				return true;
			return false;
		}));
}

bool CGameBoard::isReady() const
{
	if (m_Preset->numTemplates() != m_ShipCounters.size())
		return false;
	for (unsigned int i = 0; i<m_ShipCounters.size(); i++)
	{
		if (m_ShipCounters[i] != m_Preset->getShipAmount(i))
			return false;
	}
	return true;
}

bool CGameBoard::destroyed() const
{
	for (const auto &s : m_Ships)
		if (!s->isDestroyed())
			return false;
	return true;
}

int CGameBoard::remaining(unsigned int TemplateId) const
{
	return m_Preset->getShipAmount(TemplateId)-m_ShipCounters[TemplateId];
}

CTile::CState CGameBoard::attack(int x, int y)
{
	if (!m_Field.checkPoint(x, y))
		return CState::NO_ATTACK;
	return m_Field.at(x, y).attack();
}

bool CGameBoard::canAttack(int x, int y)
{
	auto State = m_Field.at(x, y).getState();
	return !(!m_Field.checkPoint(x,y) || State == CState::HIT || State == CState::MISS || State == CState::DESTROYED);
}

const std::vector<std::shared_ptr<CShip>>& CGameBoard::getShips() const
{
	return m_Ships;
}

const CGameBoard::CField & CGameBoard::getField() const
{
	return m_Field;
}

const CGamePreset * CGameBoard::getPreset() const
{
	return m_Preset;
}
